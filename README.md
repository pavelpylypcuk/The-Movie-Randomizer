# THE MOVIE RANDOMIZER
#### Description:

The Movie Randomizer is an app that has been designed with simplicity and ease-of-use in mind. The main purpose of this web application is to help facilitate movie selections for anyone who feels indecisive about what movie to watch. Additionally, the app also serves as a way of discovering lesser known movies, be it because of the genre, time period or language. 

Design-wise, the application is built with HTML, CSS and Bootstrap, using Bootstrap's proprietary jumbotron and form components in order to achieve a clean and understandable layout. The homepage (@index.html) features five categories from which search criteria can be selected - genre, minimum rating, language, earliest year, and latest year. The default option in each category is "Any", in order to allow for the user for up to complete randomization of movie selection. Once the user decides on search criteria and clicks on the "Randomize" button, he is redirected to a new page showing the movie picked by the randomizer (@result.html). This page shows key details about the movie, including the title, language, duration, year and a synopsis. Additionally, the page also offers the user an option to view more details on the movie's own IMDB page by clicking the yellow IMDB button. Lastly, the user has an option to either go back to their previously selected criteria or click on a "Go back" button below the synopsis which will take them to the homepage with all categories set to default.  

In terms of back-end, the application has been written in Python using Flask as the web framework and SQLite as the main SQL tool. Data-wise, the app draws on a database containing data pulled from IMDB and converted from csv into a db file (imdb.db). The key categories in the database (viz. second parahraph) are used in index.html for user selection and in the main Python program (application.py) to query for specific keywords with the help of SQLite. Within application.py, the index function ensures all of user's choices are correctly queried. If the user selects the default option in any category (i.e. the option "Any") the application turns the keyword into a symbol or a number (depending on the type of the keyword - e.g. language (string) vs year (integer)) in order to achieve an unfiltered choice in said category/-ies. 

Once the user-selected query is stored in a new variable (movies), the amount of rows within the variable is calculated in order to set an end number for the randint function (number randomizer). The randomly picked number is then used to access a specific row of the "movies" variable in order to pick only one movie (e.g. random number is 7, therefore movies[7] row is selected). This row is then instered into another table within imdb.db and is subsequently used via application.py's second function, result. In result, the result row is queried and entered via render_template into result.html with the help of Jinja. In result.html, individual elements of the result row are spread over a table to give the user a clear overview of the selected movie (viz. second paragraph).

In conclusion, the web application serves a practical purpose as it helps shorten and ease movie night decision-making. Albeit not particularly complex, this application has been designed to help its author and in that sense it has very much succeeded.

##### Credit: Stefano Leone for the IMDB database. Link - https://www.kaggle.com/stefanoleone992/imdb-extensive-dataset

